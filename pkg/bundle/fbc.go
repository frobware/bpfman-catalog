package bundle

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/operator-framework/operator-registry/alpha/action"
	"github.com/operator-framework/operator-registry/alpha/action/migrations"
	"github.com/operator-framework/operator-registry/alpha/declcfg"
	"github.com/operator-framework/operator-registry/alpha/template/basic"
	"github.com/operator-framework/operator-registry/pkg/containertools"
	"github.com/operator-framework/operator-registry/pkg/image/execregistry"
	"github.com/sirupsen/logrus"
	"sigs.k8s.io/yaml"
)

// FBCTemplate represents a File-Based Catalog template
type FBCTemplate struct {
	Schema  string        `yaml:"schema"`
	Entries []interface{} `yaml:"entries"`
}

// PackageEntry defines an OLM package
type PackageEntry struct {
	Schema         string `yaml:"schema"`
	Name           string `yaml:"name"`
	DefaultChannel string `yaml:"defaultChannel"`
}

// ChannelEntry defines an OLM channel
type ChannelEntry struct {
	Schema  string             `yaml:"schema"`
	Package string             `yaml:"package"`
	Name    string             `yaml:"name"`
	Entries []ChannelEntryItem `yaml:"entries"`
}

// ChannelEntryItem represents an entry in a channel
type ChannelEntryItem struct {
	Name string `yaml:"name"`
}

// BundleEntry defines an OLM bundle
type BundleEntry struct {
	Schema string `yaml:"schema"`
	Image  string `yaml:"image"`
	Name   string `yaml:"name"`
}

// GenerateFBCTemplate generates an FBC template for a bundle image
func GenerateFBCTemplate(bundleImage string, channel string) (*FBCTemplate, error) {
	if bundleImage == "" {
		return nil, fmt.Errorf("bundle image cannot be empty")
	}

	digestSuffix := extractDigestSuffix(bundleImage)

	if channel == "" {
		channel = "preview"
	}

	if digestSuffix != "" {
		channel = channel + "-sha-" + digestSuffix
	}

	// This is a simplified version - in production you might inspect the bundle
	bundleName := "bpfman-operator.vnext"
	packageName := "bpfman-operator"

	template := &FBCTemplate{
		Schema: "olm.template.basic",
		Entries: []interface{}{
			PackageEntry{
				Schema:         "olm.package",
				Name:           packageName,
				DefaultChannel: channel,
			},
			ChannelEntry{
				Schema:  "olm.channel",
				Package: packageName,
				Name:    channel,
				Entries: []ChannelEntryItem{
					{Name: bundleName},
				},
			},
			BundleEntry{
				Schema: "olm.bundle",
				Image:  bundleImage,
				Name:   bundleName,
			},
		},
	}

	return template, nil
}

// RenderCatalog uses the OPM library to render the FBC template into a full catalog.
func RenderCatalog(ctx context.Context, fbcTemplate *FBCTemplate) (string, error) {
	templateYAML, err := yaml.Marshal(fbcTemplate)
	if err != nil {
		return "", fmt.Errorf("marshaling FBC template: %w", err)
	}

	logger := logrus.NewEntry(logrus.New())
	logger.Logger.SetLevel(logrus.WarnLevel)

	registry, err := execregistry.NewRegistry(containertools.PodmanTool, logger)
	if err != nil {
		return "", fmt.Errorf("creating image registry: %w", err)
	}

	template := basic.Template{
		RenderBundle: func(ctx context.Context, image string) (*declcfg.DeclarativeConfig, error) {
			migs, err := migrations.NewMigrations("bundle-object-to-csv-metadata")
			if err != nil {
				return nil, fmt.Errorf("creating migrations: %w", err)
			}

			r := action.Render{
				Refs:           []string{image},
				Registry:       registry,
				AllowedRefMask: action.RefBundleImage,
				Migrations:     migs,
			}
			return r.Run(ctx)
		},
	}

	reader := bytes.NewReader(templateYAML)
	cfg, err := template.Render(ctx, reader)
	if err != nil {
		return "", fmt.Errorf("rendering template: %w", err)
	}

	var buf bytes.Buffer
	if err := declcfg.WriteYAML(*cfg, &buf); err != nil {
		return "", fmt.Errorf("writing catalog YAML: %w", err)
	}

	return buf.String(), nil
}

// GenerateCatalogDockerfile generates a Dockerfile for building a catalog image
func GenerateCatalogDockerfile() string {
	return `# Catalog Dockerfile for bpfman-operator
# Generated by bpfman-catalog tool
#
# Build with:
#   podman build -f Dockerfile.catalog -t my-catalog:dev .
#
# Push to a registry:
#   podman push my-catalog:dev ttl.sh/my-catalog:dev

FROM registry.redhat.io/openshift4/ose-operator-registry-rhel9:v4.20 AS builder

# Copy the rendered catalog
COPY catalog.yaml /configs/catalog.yaml

# Validate the catalog
RUN opm validate /configs

# Final stage - minimal image with just the catalog
FROM registry.redhat.io/openshift4/ose-operator-registry-rhel9:v4.20

# Copy validated catalog from builder
COPY --from=builder /configs /configs

# Label for OpenShift
LABEL io.openshift.release.operator=true

# Serve the catalog
ENTRYPOINT ["/bin/opm"]
CMD ["serve", "/configs"]
`
}

// GenerateBuildInstructions generates instructions for the user
func GenerateBuildInstructions(outputDir string, includeOpmStep bool) string {
	var b strings.Builder

	b.WriteString("Bundle artifacts generated successfully!\n\n")
	b.WriteString("Generated files:\n")
	b.WriteString(fmt.Sprintf("  %s/fbc-template.yaml  - FBC template for your bundle\n", outputDir))

	if !includeOpmStep {
		b.WriteString(fmt.Sprintf("  %s/catalog.yaml       - Rendered catalog (ready to build)\n", outputDir))
	}

	b.WriteString(fmt.Sprintf("  %s/Dockerfile.catalog - Dockerfile for catalog image\n\n", outputDir))

	b.WriteString("Next steps to deploy your catalog:\n\n")

	step := 1
	if includeOpmStep {
		b.WriteString(fmt.Sprintf("%d. Render the catalog from the FBC template:\n", step))
		b.WriteString(fmt.Sprintf("   opm alpha render-template basic --migrate-level=bundle-object-to-csv-metadata -o yaml %s/fbc-template.yaml > %s/catalog.yaml\n\n", outputDir, outputDir))
		step++
	}

	b.WriteString(fmt.Sprintf("%d. Build the catalog image:\n", step))
	b.WriteString(fmt.Sprintf("   cd %s\n", outputDir))
	b.WriteString("   podman build -f Dockerfile.catalog -t my-catalog:dev .\n\n")
	step++

	b.WriteString(fmt.Sprintf("%d. Push to a registry:\n", step))
	b.WriteString("   # Option 1: Push to ttl.sh (anonymous, expires in 24h)\n")
	b.WriteString("   podman push my-catalog:dev ttl.sh/my-catalog:dev\n\n")
	b.WriteString("   # Option 2: Push to quay.io (requires account)\n")
	b.WriteString("   podman push my-catalog:dev quay.io/YOUR_USERNAME/my-catalog:dev\n\n")
	step++

	b.WriteString(fmt.Sprintf("%d. Generate deployment manifests:\n", step))
	b.WriteString("   bpfman-catalog render --from-catalog ttl.sh/my-catalog:dev --output-dir ./deploy\n\n")
	step++

	b.WriteString(fmt.Sprintf("%d. Deploy to your cluster:\n", step))
	b.WriteString("   kubectl apply -f ./deploy\n")

	return b.String()
}

// extractDigestSuffix extracts the first 8 characters of a digest from an image reference
func extractDigestSuffix(imageRef string) string {
	// Look for @sha256: pattern
	if idx := strings.Index(imageRef, "@sha256:"); idx != -1 {
		digestStr := imageRef[idx+8:] // Skip "@sha256:"
		if len(digestStr) >= 8 {
			return digestStr[:8] // First 8 chars of digest
		}
	}
	return ""
}

// RenderCatalogWithBinary uses an external opm binary to render the FBC template into a full catalog.
func RenderCatalogWithBinary(ctx context.Context, fbcTemplate *FBCTemplate, ompBinPath string) (string, error) {
	templateYAML, err := yaml.Marshal(fbcTemplate)
	if err != nil {
		return "", fmt.Errorf("marshaling FBC template: %w", err)
	}

	tempDir, err := os.MkdirTemp("", "bpfman-catalog-render-")
	if err != nil {
		return "", fmt.Errorf("creating temp directory: %w", err)
	}
	defer os.RemoveAll(tempDir)

	templateFile := filepath.Join(tempDir, "template.yaml")
	if err := os.WriteFile(templateFile, templateYAML, 0644); err != nil {
		return "", fmt.Errorf("writing template file: %w", err)
	}

	cmd := exec.CommandContext(ctx, ompBinPath, "alpha", "render-template", "basic",
		"--migrate-level=bundle-object-to-csv-metadata",
		"-o", "yaml",
		templateFile)
	cmd.Dir = tempDir

	output, err := cmd.Output()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			return "", fmt.Errorf("omp command failed with exit code %d: %s", exitErr.ExitCode(), string(exitErr.Stderr))
		}
		return "", fmt.Errorf("running omp command: %w", err)
	}

	return string(output), nil
}
