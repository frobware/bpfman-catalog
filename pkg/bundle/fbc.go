package bundle

import (
	"bytes"
	"context"
	"fmt"
	"os/exec"
	"strings"

	"sigs.k8s.io/yaml"
)

// FBCTemplate represents a File-Based Catalog template
type FBCTemplate struct {
	Schema  string        `yaml:"schema"`
	Entries []interface{} `yaml:"entries"`
}

// PackageEntry defines an OLM package
type PackageEntry struct {
	Schema         string `yaml:"schema"`
	Name           string `yaml:"name"`
	DefaultChannel string `yaml:"defaultChannel"`
}

// ChannelEntry defines an OLM channel
type ChannelEntry struct {
	Schema  string             `yaml:"schema"`
	Package string             `yaml:"package"`
	Name    string             `yaml:"name"`
	Entries []ChannelEntryItem `yaml:"entries"`
}

// ChannelEntryItem represents an entry in a channel
type ChannelEntryItem struct {
	Name string `yaml:"name"`
}

// BundleEntry defines an OLM bundle
type BundleEntry struct {
	Schema string `yaml:"schema"`
	Image  string `yaml:"image"`
	Name   string `yaml:"name"`
}

// GenerateFBCTemplate generates an FBC template for a bundle image
func GenerateFBCTemplate(bundleImage string, channel string) (*FBCTemplate, error) {
	if bundleImage == "" {
		return nil, fmt.Errorf("bundle image cannot be empty")
	}

	if channel == "" {
		channel = "preview" // Default channel for development
	}

	// Extract a simple name from the bundle image
	// This is a simplified version - in production you might inspect the bundle
	bundleName := "bpfman-operator.vnext"
	packageName := "bpfman-operator"

	template := &FBCTemplate{
		Schema: "olm.template.basic",
		Entries: []interface{}{
			PackageEntry{
				Schema:         "olm.package",
				Name:           packageName,
				DefaultChannel: channel,
			},
			ChannelEntry{
				Schema:  "olm.channel",
				Package: packageName,
				Name:    channel,
				Entries: []ChannelEntryItem{
					{Name: bundleName},
				},
			},
			BundleEntry{
				Schema: "olm.bundle",
				Image:  bundleImage,
				Name:   bundleName,
			},
		},
	}

	return template, nil
}

// RenderCatalog uses opm to render the FBC template into a full catalog
func RenderCatalog(ctx context.Context, fbcTemplate *FBCTemplate) (string, error) {
	// Marshal the template to YAML
	templateYAML, err := yaml.Marshal(fbcTemplate)
	if err != nil {
		return "", fmt.Errorf("marshaling FBC template: %w", err)
	}

	// Check if opm is available
	opmPath, err := exec.LookPath("opm")
	if err != nil {
		return "", fmt.Errorf("opm not found in PATH: %w\nPlease install opm: https://docs.openshift.com/container-platform/latest/cli_reference/opm/cli-opm-install.html", err)
	}

	// Run opm render-template
	cmd := exec.CommandContext(ctx, opmPath,
		"alpha", "render-template", "basic",
		"--migrate-level=bundle-object-to-csv-metadata",
		"-o", "yaml")

	cmd.Stdin = bytes.NewReader(templateYAML)
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("running opm render-template: %w\nstderr: %s", err, stderr.String())
	}

	return stdout.String(), nil
}

// GenerateCatalogDockerfile generates a Dockerfile for building a catalog image
func GenerateCatalogDockerfile() string {
	return `# Catalog Dockerfile for bpfman-operator
# Generated by bpfman-catalog tool
#
# Build with:
#   podman build -f Dockerfile.catalog -t my-catalog:dev .
#
# Push to a registry:
#   podman push my-catalog:dev ttl.sh/my-catalog:dev

FROM registry.redhat.io/openshift4/ose-operator-registry-rhel9:v4.20 AS builder

# Copy the rendered catalog
COPY catalog.yaml /configs/catalog.yaml

# Validate the catalog
RUN opm validate /configs

# Final stage - minimal image with just the catalog
FROM registry.redhat.io/openshift4/ose-operator-registry-rhel9:v4.20

# Copy validated catalog from builder
COPY --from=builder /configs /configs

# Label for OpenShift
LABEL io.openshift.release.operator=true

# Serve the catalog
ENTRYPOINT ["/bin/opm"]
CMD ["serve", "/configs"]
`
}

// GenerateBuildInstructions generates instructions for the user
func GenerateBuildInstructions(outputDir string, includeOpmStep bool) string {
	var b strings.Builder

	b.WriteString("Bundle artifacts generated successfully!\n\n")
	b.WriteString("Generated files:\n")
	b.WriteString(fmt.Sprintf("  %s/fbc-template.yaml  - FBC template for your bundle\n", outputDir))

	if !includeOpmStep {
		b.WriteString(fmt.Sprintf("  %s/catalog.yaml       - Rendered catalog (ready to build)\n", outputDir))
	}

	b.WriteString(fmt.Sprintf("  %s/Dockerfile.catalog - Dockerfile for catalog image\n\n", outputDir))

	b.WriteString("Next steps to deploy your catalog:\n\n")

	step := 1
	if includeOpmStep {
		b.WriteString(fmt.Sprintf("%d. Render the catalog from the FBC template:\n", step))
		b.WriteString(fmt.Sprintf("   opm alpha render-template basic --migrate-level=bundle-object-to-csv-metadata -o yaml %s/fbc-template.yaml > %s/catalog.yaml\n\n", outputDir, outputDir))
		step++
	}

	b.WriteString(fmt.Sprintf("%d. Build the catalog image:\n", step))
	b.WriteString(fmt.Sprintf("   cd %s\n", outputDir))
	b.WriteString("   podman build -f Dockerfile.catalog -t my-catalog:dev .\n\n")
	step++

	b.WriteString(fmt.Sprintf("%d. Push to a registry:\n", step))
	b.WriteString("   # Option 1: Push to ttl.sh (anonymous, expires in 24h)\n")
	b.WriteString("   podman push my-catalog:dev ttl.sh/my-catalog:dev\n\n")
	b.WriteString("   # Option 2: Push to quay.io (requires account)\n")
	b.WriteString("   podman push my-catalog:dev quay.io/YOUR_USERNAME/my-catalog:dev\n\n")
	step++

	b.WriteString(fmt.Sprintf("%d. Generate deployment manifests:\n", step))
	b.WriteString("   bpfman-catalog render --from-catalog ttl.sh/my-catalog:dev --output-dir ./deploy\n\n")
	step++

	b.WriteString(fmt.Sprintf("%d. Deploy to your cluster:\n", step))
	b.WriteString("   kubectl apply -f ./deploy\n")

	return b.String()
}

// CheckOPMAvailable checks if opm is available in the system
func CheckOPMAvailable() error {
	_, err := exec.LookPath("opm")
	if err != nil {
		return fmt.Errorf("opm not found in PATH. Install from: https://docs.openshift.com/container-platform/latest/cli_reference/opm/cli-opm-install.html")
	}
	return nil
}
