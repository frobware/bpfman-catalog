package bundle

import (
	"bytes"
	"context"
	_ "embed"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/google/uuid"

	"github.com/operator-framework/operator-registry/alpha/action"
	"github.com/operator-framework/operator-registry/alpha/action/migrations"
	"github.com/operator-framework/operator-registry/alpha/declcfg"
	"github.com/operator-framework/operator-registry/alpha/template/basic"
	"github.com/operator-framework/operator-registry/pkg/containertools"
	"github.com/operator-framework/operator-registry/pkg/image/execregistry"
	"github.com/sirupsen/logrus"
	"sigs.k8s.io/yaml"
)

//go:embed templates/Makefile.tmpl
var makefileTemplate string

// BundleInfo contains extracted bundle metadata
type BundleInfo struct {
	Name    string
	Package string
}

// FBCTemplate represents a File-Based Catalog template
type FBCTemplate struct {
	Schema  string        `yaml:"schema"`
	Entries []interface{} `yaml:"entries"`
}

// PackageEntry defines an OLM package
type PackageEntry struct {
	Schema         string `yaml:"schema"`
	Name           string `yaml:"name"`
	DefaultChannel string `yaml:"defaultChannel"`
}

// ChannelEntry defines an OLM channel
type ChannelEntry struct {
	Schema  string             `yaml:"schema"`
	Package string             `yaml:"package"`
	Name    string             `yaml:"name"`
	Entries []ChannelEntryItem `yaml:"entries"`
}

// ChannelEntryItem represents an entry in a channel
type ChannelEntryItem struct {
	Name string `yaml:"name"`
}

// BundleEntry defines an OLM bundle
type BundleEntry struct {
	Schema string `yaml:"schema"`
	Image  string `yaml:"image"`
	Name   string `yaml:"name"`
}

// GenerateFBCTemplate generates an FBC template for a bundle image
func GenerateFBCTemplate(bundleImage string, channel string) (*FBCTemplate, error) {
	if bundleImage == "" {
		return nil, fmt.Errorf("bundle image cannot be empty")
	}

	if channel == "" {
		channel = "preview"
	}

	// Keep channel simple - always use "preview"

	// Extract bundle metadata to get the real bundle name
	bundleInfo, err := extractBundleInfo(bundleImage)
	if err != nil {
		return nil, fmt.Errorf("extracting bundle info: %w", err)
	}

	bundleName := bundleInfo.Name
	packageName := bundleInfo.Package

	template := &FBCTemplate{
		Schema: "olm.template.basic",
		Entries: []interface{}{
			PackageEntry{
				Schema:         "olm.package",
				Name:           packageName,
				DefaultChannel: channel,
			},
			ChannelEntry{
				Schema:  "olm.channel",
				Package: packageName,
				Name:    channel,
				Entries: []ChannelEntryItem{
					{Name: bundleName},
				},
			},
			BundleEntry{
				Schema: "olm.bundle",
				Image:  bundleImage,
				Name:   bundleName,
			},
		},
	}

	return template, nil
}

// RenderCatalog uses the OPM library to render the FBC template into a full catalog.
func RenderCatalog(ctx context.Context, fbcTemplate *FBCTemplate) (string, error) {
	templateYAML, err := yaml.Marshal(fbcTemplate)
	if err != nil {
		return "", fmt.Errorf("marshaling FBC template: %w", err)
	}

	// Suppress noisy INFO logs from operator-registry library
	logrus.SetLevel(logrus.WarnLevel)

	logger := logrus.NewEntry(logrus.New())
	logger.Logger.SetLevel(logrus.WarnLevel)

	registry, err := execregistry.NewRegistry(containertools.PodmanTool, logger)
	if err != nil {
		return "", fmt.Errorf("creating image registry: %w", err)
	}

	template := basic.Template{
		RenderBundle: func(ctx context.Context, image string) (*declcfg.DeclarativeConfig, error) {
			migs, err := migrations.NewMigrations("bundle-object-to-csv-metadata")
			if err != nil {
				return nil, fmt.Errorf("creating migrations: %w", err)
			}

			r := action.Render{
				Refs:           []string{image},
				Registry:       registry,
				AllowedRefMask: action.RefBundleImage,
				Migrations:     migs,
			}
			return r.Run(ctx)
		},
	}

	reader := bytes.NewReader(templateYAML)
	cfg, err := template.Render(ctx, reader)
	if err != nil {
		return "", fmt.Errorf("rendering template: %w", err)
	}

	var buf bytes.Buffer
	if err := declcfg.WriteYAML(*cfg, &buf); err != nil {
		return "", fmt.Errorf("writing catalog YAML: %w", err)
	}

	return buf.String(), nil
}

// GenerateCatalogDockerfile generates a Dockerfile for building a catalog image
func GenerateCatalogDockerfile() string {
	return `# Catalog Dockerfile for bpfman-operator
# Generated by bpfman-catalog tool
#
# Build with:
#   podman build -f Dockerfile.catalog -t my-catalog:dev .
#
# Push to a registry:
#   podman push my-catalog:dev ttl.sh/my-catalog:dev

FROM registry.redhat.io/openshift4/ose-operator-registry-rhel9:v4.20 AS builder

# Copy the rendered catalog
COPY catalog.yaml /configs/catalog.yaml

# Validate the catalog
RUN opm validate /configs

# Final stage - minimal image with just the catalog
FROM registry.redhat.io/openshift4/ose-operator-registry-rhel9:v4.20

# Copy validated catalog from builder
COPY --from=builder /configs /configs

# Label for OpenShift
LABEL io.openshift.release.operator=true

# Serve the catalog
ENTRYPOINT ["/bin/opm"]
CMD ["serve", "/configs"]
`
}

// GenerateBuildInstructions generates instructions for the user
func GenerateBuildInstructions(outputDir string, includeOpmStep bool, bundleImage string) string {
	var b strings.Builder
	imageUUID := uuid.New().String()

	b.WriteString("Bundle artifacts generated successfully!\n\n")
	b.WriteString("Generated files:\n")
	b.WriteString(fmt.Sprintf("  %s/fbc-template.yaml   - FBC template for your bundle\n", outputDir))

	if !includeOpmStep {
		b.WriteString(fmt.Sprintf("  %s/catalog.yaml        - Rendered catalog (ready to build)\n", outputDir))
	}

	b.WriteString(fmt.Sprintf("  %s/Dockerfile.catalog  - Dockerfile for catalog image\n", outputDir))
	b.WriteString(fmt.Sprintf("  %s/Makefile           - Makefile for automated build/push/deploy\n\n", outputDir))

	b.WriteString("To deploy your catalog:\n\n")

	if includeOpmStep {
		b.WriteString("Step-by-step workflow:\n")
		b.WriteString(fmt.Sprintf("  1. Build:  make -C %s build-catalog-image\n", outputDir))
		b.WriteString(fmt.Sprintf("  2. Push:   make -C %s push-catalog-image\n", outputDir))
		b.WriteString(fmt.Sprintf("  3. Deploy: make -C %s deploy-catalog\n\n", outputDir))

		b.WriteString("Shortcut for catalog only (build + push + deploy):\n")
		b.WriteString(fmt.Sprintf("  make -C %s build-and-deploy-catalog\n\n", outputDir))

		b.WriteString("After deploying, the catalog will be available in the OpenShift Console's\n")
		b.WriteString("OperatorHub where you can manually install the bpfman operator.\n\n")

		b.WriteString("For automatic subscription (will install the operator):\n")
		b.WriteString(fmt.Sprintf("  4. Subscribe: make -C %s subscribe\n\n", outputDir))

		b.WriteString("All-in-one workflow (build + push + deploy + subscribe):\n")
		b.WriteString(fmt.Sprintf("  make -C %s all\n\n", outputDir))
	} else {
		b.WriteString("Step-by-step workflow:\n")
		b.WriteString(fmt.Sprintf("  1. Build:  make -C %s build-catalog-image\n", outputDir))
		b.WriteString(fmt.Sprintf("  2. Push:   make -C %s push-catalog-image\n", outputDir))
		b.WriteString(fmt.Sprintf("  3. Deploy: make -C %s deploy-catalog\n\n", outputDir))

		b.WriteString("Shortcut for catalog only (build + push + deploy):\n")
		b.WriteString(fmt.Sprintf("  make -C %s build-and-deploy-catalog\n\n", outputDir))

		b.WriteString("After deploying, the catalog will be available in the OpenShift Console's\n")
		b.WriteString("OperatorHub where you can manually install the bpfman operator.\n\n")

		b.WriteString("For automatic subscription (will install the operator):\n")
		b.WriteString(fmt.Sprintf("  4. Subscribe: make -C %s subscribe\n\n", outputDir))

		b.WriteString("All-in-one workflow (build + push + deploy + subscribe):\n")
		b.WriteString(fmt.Sprintf("  make -C %s all\n\n", outputDir))
	}

	b.WriteString("Custom registry examples:\n")
	b.WriteString(fmt.Sprintf("  make -C %s IMAGE=ttl.sh/%s:1h all\n", outputDir, imageUUID))
	b.WriteString(fmt.Sprintf("  make -C %s IMAGE=quay.io/user/my-catalog all\n", outputDir))
	b.WriteString(fmt.Sprintf("\nFor all options: make -C %s help\n", outputDir))

	return b.String()
}

// extractDigestSuffix extracts the first 8 characters of a digest from an image reference
func extractDigestSuffix(imageRef string) string {
	// Look for @sha256: pattern
	if idx := strings.Index(imageRef, "@sha256:"); idx != -1 {
		digestStr := imageRef[idx+8:] // Skip "@sha256:"
		if len(digestStr) >= 8 {
			return digestStr[:8] // First 8 chars of digest
		}
	}
	return ""
}

// extractBundleInfo extracts bundle name and package from bundle metadata
func extractBundleInfo(bundleImage string) (*BundleInfo, error) {
	// Suppress noisy INFO logs from operator-registry library
	logrus.SetLevel(logrus.WarnLevel)

	logger := logrus.NewEntry(logrus.New())
	logger.Logger.SetLevel(logrus.WarnLevel)

	registry, err := execregistry.NewRegistry(containertools.PodmanTool, logger)
	if err != nil {
		return nil, fmt.Errorf("creating image registry: %w", err)
	}

	migs, err := migrations.NewMigrations("bundle-object-to-csv-metadata")
	if err != nil {
		return nil, fmt.Errorf("creating migrations: %w", err)
	}

	r := action.Render{
		Refs:           []string{bundleImage},
		Registry:       registry,
		AllowedRefMask: action.RefBundleImage,
		Migrations:     migs,
	}

	cfg, err := r.Run(context.Background())
	if err != nil {
		return nil, fmt.Errorf("rendering bundle: %w", err)
	}

	// Find the bundle entry in the rendered config
	for _, bundle := range cfg.Bundles {
		if bundle.Image == bundleImage {
			return &BundleInfo{
				Name:    bundle.Name,
				Package: bundle.Package,
			}, nil
		}
	}

	return nil, fmt.Errorf("bundle not found in rendered config")
}

// RenderCatalogWithBinary uses an external opm binary to render the FBC template into a full catalog.
func RenderCatalogWithBinary(ctx context.Context, fbcTemplate *FBCTemplate, ompBinPath string) (string, error) {
	templateYAML, err := yaml.Marshal(fbcTemplate)
	if err != nil {
		return "", fmt.Errorf("marshaling FBC template: %w", err)
	}

	tempDir, err := os.MkdirTemp("", "bpfman-catalog-render-")
	if err != nil {
		return "", fmt.Errorf("creating temp directory: %w", err)
	}
	defer os.RemoveAll(tempDir)

	templateFile := filepath.Join(tempDir, "template.yaml")
	if err := os.WriteFile(templateFile, templateYAML, 0644); err != nil {
		return "", fmt.Errorf("writing template file: %w", err)
	}

	cmd := exec.CommandContext(ctx, ompBinPath, "alpha", "render-template", "basic",
		"--migrate-level=bundle-object-to-csv-metadata",
		"-o", "yaml",
		templateFile)
	cmd.Dir = tempDir

	output, err := cmd.Output()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			return "", fmt.Errorf("omp command failed with exit code %d: %s", exitErr.ExitCode(), string(exitErr.Stderr))
		}
		return "", fmt.Errorf("running omp command: %w", err)
	}

	return string(output), nil
}

// GenerateMakefile generates a Makefile for building and deploying the catalog
func GenerateMakefile(bundleImage, binaryPath string) string {
	digestSuffix := extractDigestSuffix(bundleImage)

	localTag := "bpfman-catalog"
	if digestSuffix != "" {
		localTag = fmt.Sprintf("bpfman-catalog-sha-%s", digestSuffix)
	}

	tmpl, err := template.New("makefile").Parse(makefileTemplate)
	if err != nil {
		// Fallback to static template if parsing fails
		return fmt.Sprintf("# Error parsing Makefile template: %v\n# Bundle: %s\n", err, bundleImage)
	}

	data := struct {
		BundleImage string
		LocalTag    string
		BinaryPath  string
	}{
		BundleImage: bundleImage,
		LocalTag:    localTag,
		BinaryPath:  binaryPath,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		// Fallback to static template if execution fails
		return fmt.Sprintf("# Error executing Makefile template: %v\n# Bundle: %s\n", err, bundleImage)
	}

	return buf.String()
}
